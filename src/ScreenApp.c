/**
  ******************************************************************************
  * @file    Display/LTDC_Paint/Src/main.c 
  * @author  MCD Application Team
  * @brief   Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright © 2017 STMicroelectronics International N.V. 
  * All rights reserved.</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted, provided that the following conditions are met:
  *
  * 1. Redistribution of source code must retain the above copyright notice, 
  *    this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  * 3. Neither the name of STMicroelectronics nor the names of other 
  *    contributors to this software may be used to endorse or promote products 
  *    derived from this software without specific written permission.
  * 4. This software, including modifications and/or derivative works of this 
  *    software, must execute solely and exclusively on microcontroller or
  *    microprocessor devices manufactured by or for STMicroelectronics.
  * 5. Redistribution and use of this software other than as permitted under 
  *    this license is void and will automatically terminate your rights under 
  *    this license. 
  *
  * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS" 
  * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT 
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
  * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
  * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT 
  * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/**
 * Credits. I reproduce the credits below because I 
 * (Charles Nowell) did read the code for inspiration. I did use
 * these few lines of code as direct inspiration:
 *  

 CGratio = tW / (eW + tW);
 return (((WingPegDist) * CGratio)) - ((WingPegDist) / 2) + CGoffset;
 Copyright Aaro Malila, Finland, 2017 (aaro.malila@gmail.com)

 *  
 * The rest I wrote from scratch starting with STMicro LTDC 
 * paint program example combined with a project framework for 
 * FreeRtos and the hal library using the STM32 CubeMX tool. The
 * STM notices apply. The HX711 code was written from the 
 * datasheet. The calibration functions and all the screens are 
 * original. I modified a few of the BSP lcd/touchscreen 
 * functions because they did dumb things or didn't do what I 
 * wanted. 
 *  
 * Copyright Charles Nowell, Florida, USA, 2018 
 * (mickeysbigtimer@gmail.com) 
 *  
 * All code generated by me is mine alone and must include this
 * credit notice for source or binary distribution. All 
 * commercial rights are reserved. You may use for personal use, 
 * but not for profit. 
 *  
 * This version of the scale only uses the 
 * STM32F429 Discovery board, the sense amps and the  load 
 * cells. The wiring is 3 volts and ground from the Discovery 
 * board, plus the sense amp clock and data pins that are 
 * identified in the hx711.c/h module; these using free pins on 
 * the discovery board. Note holding the user button down on 
 * power up forces a new touch screen calibration. 
 *  
 * Thanks to Olav and Aaro for the pioneering work. 
 *  
 * Mickey 
 * mnowell129 on RCGroups. 
 * March 2018 
 *  
 *  
 */

/* 
   CG-scale originally designed and published by Olav Kallhovd; https://github.com/olkal/CG_scale
*/



/* Includes ------------------------------------------------------------------*/
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <stdarg.h>


#include "ScreenApp.h"
#include "stm32f4xx_hal.h"

// Ugly, but too lazy to write a script
// to put headers on these and build as separate files.
#include "logo.h"
#include "Arrow1.h"
#include "Arrow2.h"
#include "Arrow3.h"
#include "Arrow4.h"

#include "CalData.h"
#include "ts_calibration.h"

#include "type.h"
#include "FreeRtosAll.h"
#include "flashinterface.h"
#include "crc.h"
#include "HX711.h"





/** @addtogroup STM32F4xx_HAL_Applications
  * @{
  */

/** @addtogroup LTDC_Paint
  * @{
  */

/* Private typedef -----------------------------------------------------------*/

/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Variable to save the current size of drawing */
/* Private function prototypes -----------------------------------------------*/

// CMN
// Stuff for scale
// Calibration structure for touch screen
TSCalibrationType  localTSCalData;

/**
 * Local stack and tcb for ts 
 * task 
 * 
 */
#define tsTask_PRIORITY       6
#define tsTask                tsTask
#define tsTask_STACK_SIZE     512


TaskHandle_t tsTaskPtr;
StaticTask_t tsTaskTCB;
StackType_t  tsTaskStackData[tsTask_STACK_SIZE];
QueueHandle_t tsQueue;
StaticQueue_t tsQueueData;
#define tsQueue_DEPTH    8
uint32_t tsQueueArray[tsQueue_DEPTH];

bool getPosition(uint32_t *x,uint32_t *y)
{
   static TS_StateTypeDef  TS_State;
   /* Get Touch screen position */
   BSP_TS_GetState(&TS_State);

   /* Read the coordinate */
   if((TS_State.TouchDetected))
   {
      *x = Calibration_GetX(TS_State.X);
      *y = Calibration_GetX(TS_State.Y);
      return(true);
   }
   return(false);
}


void tsTaskFunction(void *argument)
{
   // stops compiler warning
   (void)argument;
   uint8_t error;
   uint32_t x,y;
   uint32_t combinedPosition;

   while(1)
   {
      vTaskDelay(50);
      if(getPosition(&x,&y))
      {
         combinedPosition = (x << 16) | (y & 0xffff);
         error = xQueueSend(tsQueue,(void *)&(combinedPosition),0);
         if(error == pdFAIL)
         {
            // busy, kill some extra time
            vTaskDelay(200);
         }

         vTaskDelay(200); // kill some time if someone presses so that we don't get ahead.
      }
   }
}


void startTSTask(void)
{
   tsQueue = xQueueCreateStatic(tsQueue_DEPTH,4,(uint8_t *)(tsQueueArray),&tsQueueData);

   vQueueAddToRegistry(tsQueue,"tsQueue");

   tsTaskPtr = xTaskCreateStatic(tsTaskFunction,"tsTask",tsTask_STACK_SIZE,(void *)(0),
                                 tsTask_PRIORITY,(StackType_t *const)(tsTaskStackData),
                                 (StaticTask_t *const)&(tsTaskTCB));
   // stop here if can't create.
   if(tsTaskPtr == NULL) while(1);
}

/**
 * Get the next touch. 
 * Stalls until a touch is pressed. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x 
 * @param y 
 */
void getTouch(uint32_t *x, uint32_t *y)
{
   void                    *queueReceiveValue;
   uint8_t                 queueResult;
   uint32_t                value;
   queueResult = xQueueReceive(tsQueue,(void *)&(queueReceiveValue),portMAX_DELAY);
   if(queueResult == pdFAIL)
   {
      return;
   }
   // dequeue a touch
   // then do the right thing,
   value = (uint32_t)queueReceiveValue;
   *x = value >> 16;
   *y = value & 0xffff;
}
/**
 * Get the next touch, or timeout. 
 * Allows polling for input while 
 * something else is going on where 
 * a button press may stop it. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x 
 * @param y 
 * @param timeout 
 * 
 * @return bool 
 */
bool getTouchTimeout(uint32_t *x, uint32_t *y,uint32_t timeout)
{
   void                    *queueReceiveValue;
   uint8_t                 queueResult;
   uint32_t                value;
   queueResult = xQueueReceive(tsQueue,(void *)&(queueReceiveValue),timeout);
   if(queueResult == pdFAIL)
   {
      return(false);
   }
   // dequeue a touch
   // then do the right thing,
   value = (uint32_t)queueReceiveValue;
   *x = value >> 16;
   *y = value & 0xffff;
   return(true);
}


/**
 * Put text on the screen. 
 * Saves the old colors and restores, etc. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x 
 * @param y 
 * @param text 
 * @param fgColor 
 * @param bgColor 
 * @param font 
 * @param mode 
 */
void printText(uint32_t x,uint32_t y,char *text,uint32_t fgColor,uint32_t bgColor,
               sFONT *font,Text_AlignModeTypdef mode)
{
   uint32_t oldFgColor;
   uint32_t oldBgColor;

   oldFgColor = BSP_LCD_GetTextColor();
   oldBgColor = BSP_LCD_GetBackColor();
   BSP_LCD_SetTextColor(fgColor);
   BSP_LCD_SetBackColor(bgColor);
   BSP_LCD_SetFont(font);

   BSP_LCD_DisplayStringAt(x,y,(uint8_t *)text,mode);
   BSP_LCD_SetTextColor(oldFgColor);
   BSP_LCD_SetBackColor(oldBgColor);
}


/**
 * Low level printf for the LCD 
 * Prints to an x,y coordinate in pixels. 
 * Passed a va_list so higher level functions 
 * can get passed ... as args. 
 * Like the promptMessage function.
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x pixel position
 * @param y pixel position
 * @param fgColor LCD_COLOR...
 * @param bgColor LCD_COLOR...
 * @param font &Font12, &Font24, etc.
 * @param mode CENTER_MODE, etc.
 * @param format C style printf string
 * @param list va_arg list of parameters
 */
void _printfLCD(uint32_t x,uint32_t y,uint32_t fgColor,
                uint32_t bgColor,sFONT *font,Text_AlignModeTypdef mode,
                char *format,va_list list)
{
   static char buffer[80];
   uint32_t oldFgColor;
   uint32_t oldBgColor;

   vsnprintf(buffer,80,format,list);

   oldFgColor = BSP_LCD_GetTextColor();
   oldBgColor = BSP_LCD_GetBackColor();
   BSP_LCD_SetTextColor(fgColor);
   BSP_LCD_SetBackColor(bgColor);
   BSP_LCD_SetFont(font);

   BSP_LCD_DisplayStringAt(x,y,(uint8_t *)buffer,mode);
   BSP_LCD_SetTextColor(oldFgColor);
   BSP_LCD_SetBackColor(oldBgColor);

}

/**
 * Regular old printf to the LCD 
 * To an x,y pixel position. 
 * Old colors are saved and restored. 
 * Font selection is passed. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x pixel position
 * @param y pixel position
 * @param fgColor LCD_COLOR...
 * @param bgColor LCD_COLOR...
 * @param font &Font12, &Font24, etc.
 * @param mode CENTER_MODE, etc.
 * @param format C style printf string
 */
void printfLCD(uint32_t x,uint32_t y,uint32_t fgColor,
               uint32_t bgColor,sFONT *font,Text_AlignModeTypdef mode,
               char *format,...)
{
   va_list list;
   va_start(list,format);
   _printfLCD(x,y,fgColor,bgColor,font,mode,format,list);
   va_end(list);
}

/**
 * Draw a button with text somewhere on the screen.
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x 
 * @param y 
 * @param radius 
 * @param text 
 * @param buttonColor 
 * @param textColor 
 */
void button(uint32_t x, uint32_t y, uint32_t radius, char *text, uint32_t buttonColor, uint32_t textColor)
{
   BSP_LCD_SetTextColor(LCD_COLOR_GRAY);
   BSP_LCD_FillEllipse(x,y,radius + 10,radius + 5);
   BSP_LCD_SetTextColor(buttonColor);
   BSP_LCD_FillEllipse(x,y,radius + 5,radius);
   printText(x,y - 12,text,textColor,buttonColor,&Font24,CENTER_MODE);
}

/**
 * Encode the four navigation arrows.
 */
typedef enum
{
   ARROW_UP,
   ARROW_DOWN,
   ARROW_LEFT,
   ARROW_RIGHT
}ArrowType;


/**
 * Draw one of the nav arrows on the screen somewhere
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x 
 * @param y 
 * @param arrowType 
 */
void putArrow(uint32_t x, uint32_t y,ArrowType arrowType)
{
   uint32_t  width, height;
   uint8_t   *data;
   switch(arrowType)
   {
      case ARROW_UP:
         data = (uint8_t *)pic_Arrow2_bmp;
         // not data is transposed compared to display
         width = y_Arrow2_bmp;
         height = x_Arrow2_bmp;
         break;
      case ARROW_DOWN:
         data = (uint8_t *)pic_Arrow4_bmp;
         // not data is transposed compared to display
         width = y_Arrow4_bmp;
         height = x_Arrow4_bmp;
         break;
      case ARROW_LEFT:
         data = (uint8_t *)pic_Arrow3_bmp;
         // not data is transposed compared to display
         width = y_Arrow3_bmp;
         height = x_Arrow3_bmp;
         break;
      case ARROW_RIGHT:
         data = (uint8_t *)pic_Arrow1_bmp;
         // not data is transposed compared to display
         width = y_Arrow1_bmp;
         height = x_Arrow1_bmp;
         break;
      default:
         return;
   }
   BSP_LCD_DrawBitmap2(x - width / 2,y - height / 2,data,width,height,16);
}
/**
 * How big the arrows are spaced.
 */
#define ARROW_DELTA_X  50
#define ARROW_DELTA_Y  50

/**
 * Draw the litle quad of arrows that makes the nave screen.
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x 
 * @param y 
 */
void arrowPad(uint32_t x, uint32_t y)
{
   putArrow(x,y - ARROW_DELTA_Y,ARROW_UP);
   putArrow(x + ARROW_DELTA_X,y,ARROW_RIGHT);
   putArrow(x,y + ARROW_DELTA_Y,ARROW_DOWN);
   putArrow(x - ARROW_DELTA_X,y,ARROW_LEFT);
}

/**
 * Encode what a input screen can return 
 * from the touch screen. 
 */
typedef enum
{
   GET_OK,
   GET_CANCEL,
   GET_UP,
   GET_DOWN,
   GET_LEFT,
   GET_RIGHT
}GetScreenKeys;

/**
 * Little struct to capture the x,y,radius 
 * of the input screen buttons so I can 
 * make a table to lookup if a button was pressed. 
 */
typedef struct ClassifyEntry
{
   GetScreenKeys  key;
   uint32_t       x;
   uint32_t       y;
   uint32_t       radius;
   float          xFloat;
   float          yFloat;
   float          radiusFloat;
}ClassifyEntry;

/**
 * Describes the input screen button locations and sized. 
 * Probably should make some #define constants here 
 * but I'm lazy and this is a free project.... 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 */
ClassifyEntry  getScreenClassify[] =
{
   [GET_OK] = {.key = GET_OK,.x = 60,.y = 60,.radius = 25,.xFloat = 60.0f,.yFloat = 50.0,.radiusFloat = 25.0f},
   [GET_CANCEL] = {.key = GET_CANCEL,.x = 180,.y = 60,.radius = 25,.xFloat = 180.0f,.yFloat = 50.0,.radiusFloat = 25.0f},
   [GET_UP] = {.key = GET_UP,.x = 120,.y = 190,.radius = 25,.xFloat = 120.0f,.yFloat = 190.0,.radiusFloat = 25.0f},
   [GET_DOWN] = {.key = GET_DOWN,.x = 120,.y = 290,.radius = 25,.xFloat = 120.0f,.yFloat = 290.0,.radiusFloat = 25.0f},
   [GET_LEFT] = {.key = GET_LEFT,.x = 70,.y = 240,.radius = 25,.xFloat = 70.0f,.yFloat = 240.0,.radiusFloat = 25.0f},
   [GET_RIGHT] = {.key = GET_RIGHT,.x = 170,.y = 240,.radius = 25,.xFloat = 170.0f,.yFloat = 240.0,.radiusFloat = 25.0f},
   // terminator
   [GET_RIGHT + 1] = {.key = GET_RIGHT,.x = 120,.y = 240,.radius = 0,.xFloat = 120.0f,.yFloat = 240.0,.radiusFloat = 25.0f},
};
/**
 * Return key index, or negative for out of a box.
 */
/**
 * Given a coordinate that was touched. 
 * Run through the table and see if the touch 
 * was in the radius of one of the buttons. 
 * Treats every button as a circle, but close 
 * enough on a resistive screen with low resolution 
 * anyway. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x 
 * @param y 
 * 
 * @return int32_t 
 */
int32_t classifyGetValueScreenInput(uint32_t x, uint32_t y)
{
   ClassifyEntry  *entry;
   float xpos,ypos,distance;
   float buttonx,buttony,radius;

   xpos = (float)x;
   ypos = (float)y;
   entry = getScreenClassify + 0;
   while(entry->radius)
   {
      buttonx = entry->xFloat;
      buttony = entry->yFloat;
      radius =  entry->radiusFloat;
      distance = sqrtf((xpos - buttonx) * (xpos - buttonx) + (ypos - buttony) * (ypos - buttony));
      if(distance < radius)
      {
         return((int32_t)(entry->key));
      }
      entry++;
   }
   return(-1);
}

/**
 * Funtion to wait until you click ok. 
 * Applies to the OK or X buttons 
 * at the top of most screens. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @return bool 
 */
bool getOkOrCancel(void)
{
   uint32_t x,y;
   int32_t keyStroke;
   while(1)
   {
      getTouch(&x,&y);
      keyStroke = classifyGetValueScreenInput(x,y);
      if(keyStroke >= 0)
      {
         // printfLCD(120,100,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Key is %d",keyStroke);
         switch(keyStroke)
         {
            case GET_OK:
               return(true);
               break;
            case GET_CANCEL:
               return(false);
               break;
            default:
               break;
         }
      }
   }
}

/**
 * Additional encoding when the key input 
 * can timeout. 
 */
typedef enum
{
   GET_TO_TIMEOUT,
   GET_TO_OK,
   GET_TO_CANCEL
}GetOrTimeout;

/**
 * The "click ok" function, that checks 
 * for input, but will also timeout after 
 * the prescribed time. 
 * Used to just let something free run like the 
 * sample weigh function at the confirmation stage 
 * of the calibration, or the actual run function. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param timeout 
 * 
 * @return GetOrTimeout 
 */
GetOrTimeout getOkOrCancelTimeout(uint32_t timeout)
{
   uint32_t x,y;
   int32_t keyStroke;
   while(1)
   {
      if(!getTouchTimeout(&x,&y,timeout))
      {
         return(GET_TO_TIMEOUT);
      }
      keyStroke = classifyGetValueScreenInput(x,y);
      if(keyStroke >= 0)
      {
         // printfLCD(120,100,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Key is %d",keyStroke);
         switch(keyStroke)
         {
            case GET_OK:
               return(GET_TO_OK);
               break;
            case GET_CANCEL:
               return(GET_TO_CANCEL);
               break;
            default:
               break;
         }
      }
   }
}

/**
 * Rollup function that paints a screen. 
 * Puts some text up and lets a person 
 * edit some floating point values with 
 * the touchpad. 
 * Returns true when the user is happy with 
 * the value. 
 * Allows left/right/ increment decrement of digits 
 * skips over the decimal point, wraps at the ends. 
 * I modified the put text function so that 
 * when the high bit is set 0x80, it goes 
 * inverse video. This function uses that 
 * to indicate which digit is being edited. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param msg 
 * @param value 
 * @param whole 
 * @param fraction 
 * @param result 
 * 
 * @return bool 
 */
bool getFloatValue(char *msg,float value, uint32_t whole, uint32_t fraction, float *result)
{
   static char buffer[80];
   int digitIndex; // needs to be signed
   int digits;
   char digit;
   int32_t keyStroke;
   uint32_t x,y;
   // Clear the screen and put up the navigation/edit buttons
   BSP_LCD_Clear(LCD_COLOR_BLACK);
   button(60,50,25,"OK",LCD_COLOR_GREEN,LCD_COLOR_BLACK);
   button(180,50,25,"X",LCD_COLOR_YELLOW,LCD_COLOR_BLACK);
   arrowPad(120,240);

   // get the value into an editable string
   sprintf(buffer,"%*.*f",(int)whole,(int)fraction,value);
   digits = strlen(buffer);
   digitIndex = 0;
   // mark one digit as highlighted
   buffer[digitIndex] |= 0x80;
   // clear a whole and write the value
   printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
   printfLCD(120,90,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"%s",msg);

   while(1)
   {
      // wait for and then classify a touch
      getTouch(&x,&y);
      keyStroke = classifyGetValueScreenInput(x,y);
      // if a valid touch in our set of values
      if(keyStroke >= 0)
      {
         // Do the press action
         switch(keyStroke)
         {
            case GET_OK:
               // remove the highlight that would screw up conversion
               buffer[digitIndex] &= 0x7f;
               // convert back to float
               *result = atof(buffer);
               // return success
               return(true);
               break;
            case GET_CANCEL:
               return(false);
               break;
            case GET_UP:
               // unhighlight a digit and increment it, allow rollover
               digit = buffer[digitIndex];
               digit &= 0x7f;
               digit++;
               if(digit > '9')
               {
                  digit = '0';
               }
               digit |= 0x80; // re highlight
               buffer[digitIndex] = digit;
               // repaint
               printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
               break;
            case GET_DOWN:
               // unhighlight a digit and decrement it, allow rollover
               digit = buffer[digitIndex];
               digit &= 0x7f;
               digit--;
               if(digit < '0')
               {
                  digit = '9';
               }
               digit |= 0x80; // re highlight
               buffer[digitIndex] = digit;
               printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
               break;
            case GET_RIGHT:
               // Move right do end cases, skip over the decimal point
               // move the highlight
               buffer[digitIndex] &= 0x7f;
               digitIndex++;
               if(digitIndex >= digits)
               {
                  digitIndex = 0;
               }
               if(buffer[digitIndex] == '.')
               {
                  digitIndex++;
               }
               if(digitIndex >= digits)
               {
                  digitIndex = 0;
               }
               buffer[digitIndex] |= 0x80;
               printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
               break;
            case GET_LEFT:
               // move left, skip decimal point, do end cases
               // move the highlight
               buffer[digitIndex] &= 0x7f;
               digitIndex--;
               if(digitIndex < 0)
               {
                  digitIndex = digits - 1;
               }
               if(buffer[digitIndex] == '.')
               {
                  digitIndex--;
               }
               if(digitIndex < 0)
               {
                  digitIndex = digits - 1;
               }
               buffer[digitIndex] |= 0x80;
               printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
               break;
         }
      }
      else
      {
         // printfLCD(120,100,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Key is --",keyStroke);
      }
   }
}
bool getIntegerValue(char *msg,uint32_t value, uint32_t whole, uint32_t *result)
{
   static char buffer[80];
   int digitIndex; // needs to be signed
   int digits;
   char digit;
   int32_t keyStroke;
   uint32_t x,y;
   // Clear the screen and put up the navigation/edit buttons
   BSP_LCD_Clear(LCD_COLOR_BLACK);
   button(60,50,25,"OK",LCD_COLOR_GREEN,LCD_COLOR_BLACK);
   button(180,50,25,"X",LCD_COLOR_YELLOW,LCD_COLOR_BLACK);
   arrowPad(120,240);

   // get the value into an editable string
   sprintf(buffer,"%*d",(int)whole,value);
   digits = strlen(buffer);
   digitIndex = 0;
   // mark one digit as highlighted
   buffer[digitIndex] |= 0x80;
   // clear a whole and write the value
   printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
   printfLCD(120,90,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"%s",msg);

   while(1)
   {
      // wait for and then classify a touch
      getTouch(&x,&y);
      keyStroke = classifyGetValueScreenInput(x,y);
      // if a valid touch in our set of values
      if(keyStroke >= 0)
      {
         // Do the press action
         switch(keyStroke)
         {
            case GET_OK:
               // remove the highlight that would screw up conversion
               buffer[digitIndex] &= 0x7f;
               // convert back to float
               *result = atoi(buffer);
               // return success
               return(true);
               break;
            case GET_CANCEL:
               return(false);
               break;
            case GET_UP:
               // unhighlight a digit and increment it, allow rollover
               digit = buffer[digitIndex];
               digit &= 0x7f;
               digit++;
               if(digit > '9')
               {
                  digit = '0';
               }
               digit |= 0x80; // re highlight
               buffer[digitIndex] = digit;
               // repaint
               printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
               break;
            case GET_DOWN:
               // unhighlight a digit and decrement it, allow rollover
               digit = buffer[digitIndex];
               digit &= 0x7f;
               digit--;
               if(digit < '0')
               {
                  digit = '9';
               }
               digit |= 0x80; // re highlight
               buffer[digitIndex] = digit;
               printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
               break;
            case GET_RIGHT:
               // Move right do end cases, skip over the decimal point
               // move the highlight
               buffer[digitIndex] &= 0x7f;
               digitIndex++;
               if(digitIndex >= digits)
               {
                  digitIndex = 0;
               }
               buffer[digitIndex] |= 0x80;
               printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
               break;
            case GET_LEFT:
               // move left, skip decimal point, do end cases
               // move the highlight
               buffer[digitIndex] &= 0x7f;
               digitIndex--;
               if(digitIndex < 0)
               {
                  digitIndex = digits - 1;
               }
               buffer[digitIndex] |= 0x80;
               printText(120,120,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
               break;
         }
      }
      else
      {
         // printfLCD(120,100,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Key is --",keyStroke);
      }
   }
}


/**
 * Constants for root menu
 */
#define CAL_X      120
#define CAL_Y      50
#define CAL_RADIUS 40

#define TARE_X      120
#define TARE_Y      150
#define TARE_RADIUS 40

#define RUN_X      120
#define RUN_Y      250
#define RUN_RADIUS 40

/**
 * Classify root menu presses. 
 * Got written before the classify structure got written, 
 * so could probably be converted to table driven like 
 * the input screen classifier. 
 * But it works for now. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param x 
 * @param y 
 * 
 * @return int32_t 
 */
int32_t classifyRootMenuPress(uint32_t x, uint32_t y)
{
   float xpos,ypos,distance;
   float buttonx,buttony,radius;
   xpos = (float)x;
   ypos = (float)y;
   buttonx = (float)CAL_X;
   buttony = (float)CAL_Y;
   radius = (float)CAL_RADIUS;

   distance = sqrtf((xpos - buttonx) * (xpos - buttonx) + (ypos - buttony) * (ypos - buttony));
   if(distance < radius)
   {
      return(0);
   }
   buttonx = (float)TARE_X;
   buttony = (float)TARE_Y;
   radius = (float)TARE_RADIUS;
   distance = sqrtf((xpos - buttonx) * (xpos - buttonx) + (ypos - buttony) * (ypos - buttony));
   if(distance < radius)
   {
      return(1);
   }
   buttonx = (float)RUN_X;
   buttony = (float)RUN_Y;
   radius = (float)RUN_RADIUS;
   distance = sqrtf((xpos - buttonx) * (xpos - buttonx) + (ypos - buttony) * (ypos - buttony));
   if(distance < radius)
   {
      return(2);
   }

   return(-1);
}

/**
 * Sort 5 values, used by the median filter.
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param values 
 */
void sort5(float values[])
{
   int i,j;
   float temp;
   for(i = 0;i < 4;i++)
   {
      for(j = i;j < 5;j++)
      {
         if(values[i] > values[j])
         {
            temp = values[i];
            values[i] = values[j];
            values[j] = temp;
         }
      }
   }
}
/*****************************************************************************/
/*****************************************************************************/
// Local scale cal data
// This is the working data that is restored from flash.
/*****************************************************************************/
/*****************************************************************************/
ScaleCalibrationType  scaleCalibrationData =
{
   // non zero values to make the math not crash.
   // these get updated and written into
   // flash in calibration
   .frontZero     =  0.0f,
   .backZero      =  0.0f,
   .frontAtCal    =  1000.0f,   // made up
   .backAtCal     =  1000.0f,   // made up
   .frontSlope    =  1.0f,      // made up
   .backSlope     =  1.0f,      // made up
   .calWeight     =  5000.00f,  // made up
   .WingPegDist   =  120.0f,    // some nominal value
   .LEstopperDist =  30.0f,     // some nominal value
   .frontGain     =  3,
   .backGain      =  3
};
void initCalData(void)
{
   scaleCalibrationData.frontZero = 0.0f;
   scaleCalibrationData.backZero  = 0.0f;
   scaleCalibrationData.frontAtCal = 1000.0f; // made up
   scaleCalibrationData.backAtCal =  1000.0f; // made up
   scaleCalibrationData.frontSlope = 1.0f;  // made up
   scaleCalibrationData.backSlope = 1.0f;   // made up
   scaleCalibrationData.calWeight = 500.00f; // made up
   scaleCalibrationData.WingPegDist = 119.8f; // some nominal value
   scaleCalibrationData.LEstopperDist = 30.0f; // some nominal value
}
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

/**
 * Read the sensors, 
 * Kinda owns a hunk of the screen when it does. 
 * If Display is selected. 
 * Does a 5th order median filter on the data. 
 * Samples for about 5 seconds. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param front 
 * @param back 
 */
void readSensors(float *front,float *back, bool displayOn)
{
   float fValues[5];
   float bValues[5];
   int i;
   int32_t                 frontRaw,backRaw;

   for(i = 0;i < 5;i++)
   {
      if(displayOn)
      {
         printfLCD(120,150,LCD_COLOR_BLACK,LCD_COLOR_WHITE,&Font24,CENTER_MODE,"Reading");
      }
      vTaskDelay(500);
      if(displayOn)
      {
         // inverse video so it will blink
         printfLCD(120,150,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Reading");
      }
      vTaskDelay(500);
      getLoadCellValues(&frontRaw,&backRaw);
      fValues[i] = (float)frontRaw;
      bValues[i] = (float)backRaw;
   }
   sort5(fValues);
   sort5(bValues);
   *front = fValues[2];
   *back = bValues[2];

}

/**
 * Reusable function to put up two 
 * lines of text, with arguments if present. 
 * User has to hit ok or cancel to accept the 
 * presented value or message. 
 * Stays here till one of the buttons is pressed. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param textA 
 * @param textB 
 * 
 * @return bool 
 */
bool promptMessage(bool waitForAnswer,char *textA,char *textB,...)
{
   va_list list;
   va_start(list,textB);

   BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
   BSP_LCD_FillRect(0,120,240,180);
   printfLCD(120,120,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,textA);
   _printfLCD(120,150,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,textB,list);
   button(60,50,25,"OK",LCD_COLOR_GREEN,LCD_COLOR_BLACK);
   button(180,50,25,"X",LCD_COLOR_YELLOW,LCD_COLOR_BLACK);
   va_end(list);
   if(waitForAnswer)
   {
      return(getOkOrCancel());
   }
   return(true);

}

/**
 * The calibration function. 
 * Called at startup if flash is corrupt/empty. 
 * Or called on demand by user. At any stage if cancel is hit 
 * (X) returns false and doesn't complete. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param justWeigh 
 * 
 * @return bool 
 */
bool calibrationOperation(bool justWeigh)
{
   bool                     choice;
   int32_t                 frontRaw,backRaw;
   float                   frontSample;
   float                   backSample;
   float                   dummy;
   float fValues[5];
   float bValues[5];


   if(!justWeigh)
   {

      if(!getIntegerValue("Front Gain(1-3)",scaleCalibrationData.frontGain,1,&scaleCalibrationData.frontGain))
      {
         return(false);
      }
      if(!getIntegerValue("Back Gain(1-3)",scaleCalibrationData.backGain,1,&scaleCalibrationData.backGain))
      {
         return(false);
      }
      setHX711Gain(scaleCalibrationData.frontGain,scaleCalibrationData.backGain);
      // let scale adjust
      vTaskDelay(200);
      BSP_LCD_Clear(LCD_COLOR_BLACK);
      choice = promptMessage(true,"Clear Scale","Hit ok");
      if(!choice)
      {
         return(false);
      }
      // now get the front and rear samples.
      readSensors(&(scaleCalibrationData.frontZero),&(scaleCalibrationData.backZero),true);

      if(!getFloatValue("Cal Weight(g)",scaleCalibrationData.calWeight,4,2,&scaleCalibrationData.calWeight))
      {
         return(false);
      }
      BSP_LCD_Clear(LCD_COLOR_BLACK);
      choice = promptMessage(true,"Put weight(FT)","Hit ok");
      if(!choice)
      {
         return(false);
      }
      readSensors(&(scaleCalibrationData.frontAtCal),&dummy,true);

      BSP_LCD_Clear(LCD_COLOR_BLACK);
      choice = promptMessage(true,"Put weight(BK)","Hit ok");
      if(!choice)
      {
         return(false);
      }
      readSensors(&dummy,&(scaleCalibrationData.backAtCal),true);

      scaleCalibrationData.frontSlope = scaleCalibrationData.calWeight / (scaleCalibrationData.frontAtCal - scaleCalibrationData.frontZero);
      scaleCalibrationData.backSlope = scaleCalibrationData.calWeight / (scaleCalibrationData.backAtCal - scaleCalibrationData.backZero);

      BSP_LCD_Clear(LCD_COLOR_BLACK);
      choice = promptMessage(true,"Remove Weight","Hit ok");
      if(!choice)
      {
         return(false);
      }
   }

   // get span
   BSP_LCD_Clear(LCD_COLOR_BLACK);
   if(!getFloatValue("Span(mm)",scaleCalibrationData.WingPegDist,4,2,&scaleCalibrationData.WingPegDist))
   {
      return(false);
   }

   BSP_LCD_Clear(LCD_COLOR_BLACK);
   if(!getFloatValue("Offset(mm)",scaleCalibrationData.LEstopperDist,4,2,&scaleCalibrationData.LEstopperDist))
   {
      return(false);
   }

   BSP_LCD_Clear(LCD_COLOR_BLACK);
   choice = promptMessage(false,"Sample Weigh","Hit ok");
   {
      GetOrTimeout whatToDo;
      int counter;
      counter = 0;
      while(1)
      {
         whatToDo = getOkOrCancelTimeout(200);
         if(whatToDo == GET_TO_CANCEL)
         {
            return(false);
         }
         if(whatToDo == GET_TO_OK)
         {
            break;
         }
         getLoadCellValues(&frontRaw,&backRaw);
         frontSample = (float)frontRaw;
         backSample = (float)backRaw;
         frontSample -= scaleCalibrationData.frontZero;
         frontSample *= scaleCalibrationData.frontSlope;
         backSample -= scaleCalibrationData.backZero;
         backSample *= scaleCalibrationData.backSlope;
         fValues[counter] = frontSample;
         bValues[counter++] = backSample;
         if(counter == 5)
         {
            sort5(fValues);
            sort5(bValues);
            BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
            BSP_LCD_FillRect(0,180,240,300);
            printfLCD(120,180,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"FT=%04.2f",fValues[2]);
            printfLCD(120,210,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"BK=%04.2f",bValues[2]);
            counter = 0;
         }
      }
   }
   return(true);
}
/**
 * Set the zero point. 
 * Doesn't change the stored data or the 
 * slope of the calibration. 
 * Just uses a new zero point. 
 * Tested with real airplane and makes 
 * a difference if you tare it once in a while 
 * and at startup. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 */
void tareOperation(void)
{
   bool choice;
   BSP_LCD_Clear(LCD_COLOR_BLACK);
   choice = promptMessage(true,"Empty scale!","Hit ok");
   if(!choice)
   {
      return;;
   }
   // now get the front and rear samples.
   readSensors(&(scaleCalibrationData.frontZero),&(scaleCalibrationData.backZero),true);
   choice = promptMessage(true,"Tare Complete","Hit ok");

}


/**
 * Actually run the scale with the calibration.
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 */
void runOperation(void)
{
   int32_t                 frontRaw;
   int32_t                 backRaw;
   float                   frontSample;
   float                   backSample;
   float                   fValues[5];
   float                   bValues[5];
   float                   cgLocation;
   float                   backToFrontRatio;
   float                   CGoffset = ((scaleCalibrationData.WingPegDist / 2) + scaleCalibrationData.LEstopperDist);

   BSP_LCD_Clear(LCD_COLOR_BLACK);
   promptMessage(false,"Reading","");
   {
      GetOrTimeout whatToDo;
      int counter;
      counter = 0;
      while(1)
      {
         whatToDo = getOkOrCancelTimeout(200);
         if(whatToDo == GET_TO_CANCEL)
         {
            break;
         }
         if(whatToDo == GET_TO_OK)
         {
            break;
         }
         getLoadCellValues(&frontRaw,&backRaw);
         frontSample = (float)frontRaw;
         backSample = (float)backRaw;
         frontSample -= scaleCalibrationData.frontZero;
         frontSample *= scaleCalibrationData.frontSlope;
         backSample -= scaleCalibrationData.backZero;
         backSample *= scaleCalibrationData.backSlope;
         fValues[counter] = frontSample;
         bValues[counter++] = backSample;
         if(counter == 5)
         {
            float frontLoad,backLoad;
            sort5(fValues);
            sort5(bValues);
            frontLoad = fValues[2];
            backLoad = bValues[2];

            backToFrontRatio = (backLoad) / (frontLoad + backLoad);
            cgLocation = (((scaleCalibrationData.WingPegDist) * backToFrontRatio)) - ((scaleCalibrationData.WingPegDist) / 2) + CGoffset;


            BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
            BSP_LCD_FillRect(0,180,240,300);

            printfLCD(120,180,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"FT SNSR=%04.2f",frontLoad);
            printfLCD(120,210,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"BK SNSR=%04.2f",backLoad);
            printfLCD(120,240,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"AUW=%04.2f",frontLoad + backLoad);
            printfLCD(120,270,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"CG=%04.2fmm",cgLocation);
            counter = 0;
         }
      }
   }
}

void drawRootMenu(void)
{
   BSP_LCD_Clear(LCD_COLOR_BLACK);
   button(120,50,40,"Cal",LCD_COLOR_RED,LCD_COLOR_WHITE);
   button(120,150,40,"Tare",LCD_COLOR_YELLOW,LCD_COLOR_BLACK);
   button(120,250,40,"Run",LCD_COLOR_GREEN,LCD_COLOR_BLACK);

}

/**
 * Do the root menu after startup. 
 * Make buttons for calibrate, tare or run. 
 * Do the selected function. 
 * Never returns. 
 * 
 * @author Charles "Mickey" Nowell (3/24/2018)
 * 
 * @param void 
 */
void rootMenu(void)
{
   void                    *queueReceiveValue;
   uint8_t                 queueResult;
   uint32_t                 value;
   uint32_t                 x,y;
   int32_t                  buttonNumber;

   drawRootMenu();

   while(1)
   {
      queueResult = xQueueReceive(tsQueue,(void *)&(queueReceiveValue),portMAX_DELAY);
      if(queueResult == pdFAIL)
      {
         continue;
      }
      // dequeue a touch
      // then do the right thing,
      value = (uint32_t)queueReceiveValue;
      x = value >> 16;
      y = value & 0xffff;
      // sprintf(buffer,"pos = %3d,%3d",x,y);
      // printText(120,160,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
      if(buttonNumber = classifyRootMenuPress(x,y),buttonNumber >= 0)
      {
         // sprintf(buffer,"Button = %3d",buttonNumber);
         // printText(120,190,buffer,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE);
         switch(buttonNumber)
         {
            case 0:
               button(120,50,40,"Cal",LCD_COLOR_DARKGRAY,LCD_COLOR_WHITE);
               vTaskDelay(500);
               button(120,50,40,"Cal",LCD_COLOR_RED,LCD_COLOR_WHITE);
               if(calibrationOperation(false))
               {
                  updateScaleCalibration(&scaleCalibrationData);
                  BSP_LCD_Clear(LCD_COLOR_BLACK);
                  printfLCD(120,120,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Saving");
                  printfLCD(120,150,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Please wait!");
                  pushCalToFlash();
               }
               else
               {
                  // restore the old data if we cancel
                  loadScaleCalibration(&scaleCalibrationData);
               }
               drawRootMenu();
               break;
            case 1:
               button(120,150,40,"Tare",LCD_COLOR_DARKGRAY,LCD_COLOR_WHITE);
               vTaskDelay(500);
               button(120,150,40,"Tare",LCD_COLOR_YELLOW,LCD_COLOR_BLACK);
               tareOperation();
               drawRootMenu();
               break;
            case 2:
               button(120,250,40,"Run",LCD_COLOR_DARKGRAY,LCD_COLOR_WHITE);
               vTaskDelay(500);
               button(120,250,40,"Run",LCD_COLOR_GREEN,LCD_COLOR_BLACK);
               runOperation();
               drawRootMenu();
               break;
         }


      }
   }
}

/**
 * Splash screen at startup.
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 */
void splash(void)
{
   BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
   BSP_LCD_SetBackColor(LCD_COLOR_YELLOW);

   BSP_LCD_SetFont(&Font24);
   BSP_LCD_DisplayStringAt(120,BSP_LCD_GetYSize() / 2 - 44,(uint8_t *)"Kyle's",CENTER_MODE);
   BSP_LCD_DisplayStringAt(120,BSP_LCD_GetYSize() / 2 - 12,(uint8_t *)"Awesome",CENTER_MODE);
   BSP_LCD_DisplayStringAt(120,BSP_LCD_GetYSize() / 2 + 30,(uint8_t *)"Scale",CENTER_MODE);

   BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
   {
      int i;
      int width,height;
      width = BSP_LCD_GetXSize();
      height = BSP_LCD_GetYSize();
      width -= 5;
      height -= 5;
      for(i = 0;i < 5;i++)
      {
         BSP_LCD_DrawRect(1 + i,1 + i,width,height);
         width -= 2;
         height -= 2;
      }
   }
}

/**
 * Displays Team USA F3K logo.
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param void 
 */
void showLogo(void)
{
   BSP_LCD_Clear(LCD_COLOR_WHITE);
   BSP_LCD_DrawBitmap2(35,50,(uint8_t *)pic_logo_bmp,y_logo_bmp,x_logo_bmp,16);
}

/* Private functions ---------------------------------------------------------*/


/**
 * This is the basic application that runs the gui 
 * and uses the ts task and hx711 data. 
 * 
 * @author Charles "Mickey" Nowell (3/26/2018)
 * 
 * @param void 
 * 
 * @return none
 */
void screenApp(void)
{
   bool forceDefault;
   /**
    * This is all boilerplate from the STM Demo for 
    * the paint program demo for the STM32F429 Disco board. 
    */
   BSP_LCD_Init();
   /* Layer2 Init */
   BSP_LCD_LayerDefaultInit(1,LCD_FRAME_BUFFER_LAYER1);
   /* Set Foreground Layer */
   BSP_LCD_SelectLayer(1);
   /* Clear the LCD */
   BSP_LCD_Clear(LCD_COLOR_WHITE);
   BSP_LCD_SetColorKeying(1,LCD_COLOR_WHITE);
   BSP_LCD_SetLayerVisible(1,DISABLE);

   /* Layer1 Init */
   BSP_LCD_LayerDefaultInit(0,LCD_FRAME_BUFFER_LAYER0);

   /* Set Foreground Layer */
   BSP_LCD_SelectLayer(0);

   /* Enable The LCD */
   BSP_LCD_DisplayOn();

   /* Clear the LCD */
   BSP_LCD_Clear(LCD_COLOR_WHITE);

   /*##-2- Touch screen initialization ########################################*/

   BSP_TS_Init(BSP_LCD_GetXSize(),BSP_LCD_GetYSize());

   BSP_LCD_Clear(LCD_COLOR_BLACK);

   // All the custom code
   splash();
   vTaskDelay(500);
   showLogo();
   vTaskDelay(1000);
   // startup order is important
   // this can start now.
   startHX711Task();

   if((HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_SET))
   {
      forceDefault = true;
   }
   else
   {
      forceDefault = false;
   }

   // now reload cal for scale purposes
   if(!forceDefault && loadCalFromFlash())
   {
      // push the cal data to local structures
      loadTSCalibration(&localTSCalData);
      configureTouchScreen(&localTSCalData);
      loadScaleCalibration(&scaleCalibrationData);
      setHX711Gain(scaleCalibrationData.frontGain,scaleCalibrationData.backGain);

      // have to wait and do this here because
      // the ts cal mucks with what the task wants to do
      // and apparently the library is not reentrant
      // or multitasking safe
      // needs a semaphore
      startTSTask();
   }
   else
   {
      // cal is bad, do touchscreen first
      if(Touchscreen_Calibration(&localTSCalData))
      {
         updateTSCalibration(&localTSCalData);
         configureTouchScreen(&localTSCalData);
      }
      // have to wait and do this here because
      // the ts cal mucks with what the task wants to do
      // and apparently the library is not reentrant
      // or multitasking safe
      // needs a semaphore
      // now start touchscreen task wiht good data
      startTSTask();
      // cal is bad, so must do cal.
      if(calibrationOperation(false))
      {
         updateScaleCalibration(&scaleCalibrationData);
      }
      setHX711Gain(scaleCalibrationData.frontGain,scaleCalibrationData.backGain);
      // save the cal
      BSP_LCD_Clear(LCD_COLOR_BLACK);
      printfLCD(120,120,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Saving");
      printfLCD(120,150,LCD_COLOR_WHITE,LCD_COLOR_BLACK,&Font24,CENTER_MODE,"Please wait!");
      pushCalToFlash();
   }
   // this never returns
   rootMenu();
}


/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*
Required for static allocation for Free RTOS.
*/
/****************************************************************************/
/****************************************************************************/
/* configUSE_STATIC_ALLOCATION is set to 1, so the application must provide an
implementation of vApplicationGetIdleTaskMemory() to provide the memory that is
used by the Idle task. */
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize)
{
   /* If the buffers to be provided to the Idle task are declared inside this
      function then they must be declared static - otherwise they will be allocated on
      the stack and so not exists after this function exits. */
   static StaticTask_t xIdleTaskTCB;
   static StackType_t uxIdleTaskStack[configMINIMAL_STACK_SIZE];

   /* Pass out a pointer to the StaticTask_t structure in which the Idle task's
   state will be stored. */
   *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;

   /* Pass out the array that will be used as the Idle task's stack. */
   *ppxIdleTaskStackBuffer = uxIdleTaskStack;

   /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
   Note that, as the array is necessarily of type StackType_t,
   configMINIMAL_STACK_SIZE is specified in words, not bytes. */
   *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
